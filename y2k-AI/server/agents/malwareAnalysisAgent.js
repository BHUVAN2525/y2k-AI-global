/**
 * Malware Analysis Agent â€” Specialized agent for deep malware analysis
 * 
 * Part of the Y2K Multi-Agent Swarm Architecture.
 * Focuses exclusively on malware analysis, feature extraction, signature matching,
 * and behavioral analysis. Delegates to Python engine for ML classification.
 */
const { geminiChat } = require('../services/apiIntegration');
const toolExecutor = require('../services/toolExecutor');

const SYSTEM_PROMPT = `You are Y2K Malware Analysis Agent â€” a specialized AI malware analyst.

PERSONALITY:
- Methodical, precise, forensic-minded
- You think like a reverse engineer and malware researcher
- You provide deep technical analysis of suspicious files
- You map every behavior to MITRE ATT&CK techniques

SPECIALIZATION:
- Static analysis: PE headers, imports, strings, entropy, packing detection
- Dynamic analysis: API calls, network behavior, file system changes, registry modifications
- ML classification: interpret model predictions and feature importance
- Signature matching: YARA rules, IOC extraction
- Memory forensics: injected DLLs, process hollowing, shellcode detection

RESPONSE STYLE:
1. Start with a verdict: MALICIOUS / SUSPICIOUS / BENIGN with confidence %
2. List key indicators with MITRE technique IDs
3. Provide a technical breakdown of each finding
4. End with recommended containment and remediation steps
5. Use markdown formatting with tables for structured data

ABSOLUTE RULES:
- Never execute or run malware outside the sandbox
- Always recommend isolation before analysis
- Provide defense recommendations with every finding`;

const HEURISTIC_RESPONSES = {
    analyze: `ðŸ¦  **Malware Analysis Agent**

I specialize in deep malware analysis. I can:

â€¢ **Static Analysis**: PE headers, imports, strings, entropy, packing
â€¢ **Dynamic Analysis**: API calls, network behavior, file changes
â€¢ **ML Classification**: Interpret model predictions and feature importance
â€¢ **Signature Matching**: YARA rules, IOC extraction
â€¢ **Memory Analysis**: Injected DLLs, process hollowing, shellcode

Upload a file via the **Analyzer** page, then ask me about the results.

ðŸ’¡ **Tip:** Add your Gemini API key for AI-powered deep analysis.`,

    suspicious: `ðŸ” **Suspicious Indicators Found**

Common indicators I look for:
| Indicator | MITRE | Risk |
|---|---|---|
| High entropy sections | T1027 | Packed/encrypted code |
| CreateRemoteThread | T1055 | Process injection |
| VirtualAllocEx | T1055 | Memory manipulation |
| Network callbacks | T1071 | C2 communication |
| Registry persistence | T1547 | Boot/startup persistence |

Upload your file for detailed analysis.`,
};

function heuristicFallback(message) {
    const m = message.toLowerCase();
    if (/analyze|scan|check|upload|file/i.test(m)) return HEURISTIC_RESPONSES.analyze;
    if (/suspicious|indicator|ioc|detect/i.test(m)) return HEURISTIC_RESPONSES.suspicious;
    return HEURISTIC_RESPONSES.analyze;
}

class MalwareAnalysisAgent {
    constructor() {
        this.name = 'Malware Analysis Agent';
        this.specialty = 'malware_analysis';
        this.version = '1.0';
    }

    /**
     * Check if this agent should handle a given message
     */
    canHandle(message) {
        const patterns = [
            /malware|virus|trojan|ransomware|worm|rootkit|spyware|adware/i,
            /analyze.*file|file.*analys|scan.*file|upload/i,
            /pe.*header|import.*table|string.*extract|entropy/i,
            /yara|signature|ioc|indicator/i,
            /sandbox.*result|dynamic.*analysis|static.*analysis/i,
            /packed|obfuscat|encrypt.*payload|shellcode/i,
            /inject.*dll|process.*hollow|hook/i,
        ];
        return patterns.some(p => p.test(message));
    }

    async think(message, sessionId = null, history = []) {
        const tools = [
            ...(toolExecutor.TOOL_DEFINITIONS.blue || []),
            { name: 'analyze_malware_deep', description: 'Run deep static+ML analysis on a file via Python engine', parameters: { type: 'object', properties: { filename: { type: 'string' } }, required: ['filename'] } },
        ];

        const steps = [{ type: 'thinking', message: `Malware Analysis Agent examining: "${message.slice(0, 60)}..."` }];

        try {
            const messages = [
                ...history.slice(-6),
                { role: 'user', content: message }
            ];

            let geminiResponse;
            try {
                geminiResponse = await geminiChat({ systemPrompt: SYSTEM_PROMPT, messages, tools });
            } catch (err) {
                if (err.message === 'NO_GEMINI_KEY') {
                    steps.push({ type: 'info', message: 'No Gemini key â€” using built-in analysis' });
                    return { response: heuristicFallback(message), steps, agent: this.name, intent: 'heuristic', toolsUsed: [] };
                }
                throw err;
            }

            let finalText = geminiResponse.text;
            const toolsUsed = [];

            if (geminiResponse.toolCalls?.length > 0) {
                for (const tc of geminiResponse.toolCalls) {
                    steps.push({ type: 'tool_call', message: `${this.name}: ${tc.name}(${JSON.stringify(tc.args).slice(0, 80)})` });
                    const result = await toolExecutor.run(tc.name, tc.args, 'blue', sessionId);
                    toolsUsed.push({ tool: tc.name, args: tc.args, result });
                    steps.push({ type: 'tool_result', message: `${tc.name} â†’ ${result.error ? 'Error' : 'Success'}` });
                }

                // Synthesize with tool results
                const toolSummary = toolsUsed.map(t =>
                    `Tool: ${t.tool}\nResult: ${JSON.stringify(t.result).slice(0, 1000)}`
                ).join('\n\n');

                try {
                    const synthesis = await geminiChat({
                        systemPrompt: SYSTEM_PROMPT,
                        messages: [...messages,
                        { role: 'assistant', content: finalText || 'Analysis results:' },
                        { role: 'user', content: `Tool results:\n\n${toolSummary}\n\nProvide a complete malware analysis report based on these results.` }
                        ],
                        tools: []
                    });
                    finalText = synthesis.text || finalText;
                } catch { }
            }

            return {
                response: finalText || heuristicFallback(message),
                steps, agent: this.name, intent: 'gemini', toolsUsed
            };
        } catch (err) {
            return { response: heuristicFallback(message), steps, agent: this.name, intent: 'fallback', toolsUsed: [], error: err.message };
        }
    }
}

module.exports = new MalwareAnalysisAgent();

/**
 * Malware Analysis Service â€” Autonomous Forensic Pipeline
 * 
 * Implements a "Market Standard" analysis workflow:
 * 1. Static Triage (Hashes, Strings, Headers)
 * 2. Sandbox Provisioning
 * 3. Dynamic Analysis (Syscalls, Signal Monitoring)
 * 4. Network Forensics (DNS, Connection Tracking)
 * 5. Report Aggregation
 */

const sandbox = require('./sandboxService');
const toolExecutor = require('./toolExecutor');
const mlEngine = require('./mlEngine');
const DynamicAnalysisAgent = require('./dynamicAnalysisAgent');
const { getKey, vtLookup } = require('./apiIntegration');
const { v4: uuidv4 } = require('uuid');

class MalwareAnalysisService {
    constructor() {
        this.analysisRuns = new Map();
        this.aiAgent = new DynamicAnalysisAgent(getKey('gemini_api_key'));
    }

    /**
     * Start autonomous analysis on a specific file
     */
    async analyzeFile(sessionId, filePath, fileName) {
        const analysisId = uuidv4();
        console.log(`[MalwareAnalysis] Starting autonomous analysis for: ${fileName} (${analysisId})`);

        const run = {
            id: analysisId,
            sessionId,
            target: { filePath, fileName },
            status: 'initializing',
            startTime: new Date(),
            findings: {
                static: {},
                ml: {},
                vt: null,
                dynamic: { syscalls: [], processes: [] },
                network: [],
                mitre: [],
                ai_report: null
            }
        };

        this.analysisRuns.set(analysisId, run);

        try {
            // Step 1: Deep Static & ML Analysis
            run.status = 'static_analysis';
            run.findings.ml = await mlEngine.analyzeFile(filePath, fileName);
            run.findings.static = await this._performStaticAnalysis(sessionId, filePath);

            // Step 1.5: VirusTotal Cross-Check (Global Intel)
            const hashValue = run.findings.ml.hashes?.sha256;
            if (hashValue) {
                console.log(`[MalwareAnalysis] Cross-checking VirusTotal for: ${hashValue}`);
                run.findings.vt = await vtLookup(hashValue);
            }

            // Step 2: Dynamic Analysis Execution (Safe Sandbox)
            run.status = 'dynamic_analysis';
            run.findings.dynamic = await this._performDynamicAnalysis(sessionId, filePath);

            // Step 3: Network Diagnostics
            run.status = 'network_forensics';
            run.findings.network = await this._performNetworkAnalysis(sessionId);

            // Step 4: AI Agent Aggregation & Mitigation Generation
            run.status = 'generating_report';
            const artifacts = {
                filename: fileName,
                fileSize: run.findings.ml.file_size,
                output: run.findings.dynamic.syscallSummary || '',
                processes: { after: JSON.stringify(run.findings.dynamic.processLeaked) },
                network: { after: JSON.stringify(run.findings.network) },
                ml_score: run.findings.ml.risk_score,
                is_malware: run.findings.ml.is_malware
            };
            run.findings.ai_report = await this.aiAgent.orchestrateAnalysis(artifacts);

            run.status = 'completed';
            run.endTime = new Date();

            return run;
        } catch (err) {
            console.error(`[MalwareAnalysis] Error during analysis ${analysisId}:`, err);
            run.status = 'failed';
            run.error = err.message;
            return run;
        }
    }

    async _performStaticAnalysis(sessionId, filePath) {
        console.log('[MalwareAnalysis] Running Static Triage');

        const commands = [
            `file ${filePath}`,
            `sha256sum ${filePath}`,
            `strings ${filePath} | head -n 50`,
            `readelf -h ${filePath} || echo "Not ELF"`,
            `checksec --file=${filePath} || echo "checksec n/a"`
        ];

        const results = {};
        for (const cmd of commands) {
            try {
                const output = await sandbox.executeCommand(sessionId, cmd);
                results[cmd.split(' ')[0]] = output;
            } catch (e) {
                results[cmd.split(' ')[0]] = 'Error or tool missing';
            }
        }
        return results;
    }

    async _performDynamicAnalysis(sessionId, filePath) {
        console.log('[MalwareAnalysis] Running Dynamic Behavioral Analysis');

        // Ensure file is executable
        await sandbox.executeCommand(sessionId, `chmod +x ${filePath}`);

        // Run with strace to capture syscalls (timeout after 5s to prevent hang)
        const traceCmd = `timeout 5s strace -e trace=all ${filePath} 2>&1`;

        try {
            const syscalls = await sandbox.executeCommand(sessionId, traceCmd);

            // Check process list leftovers
            const psList = await sandbox.executeCommand(sessionId, `ps aux | grep ${filePath.split('/').pop()} | grep -v grep`);

            return {
                syscallSummary: syscalls.split('\n').slice(-20).join('\n'), // last 20 syscalls
                processLeaked: psList.trim().length > 0,
                fullTraceAvailable: true
            };
        } catch (e) {
            return { error: 'Dynamic analysis failed or timed out', trace: e.message };
        }
    }

    async _performNetworkAnalysis(sessionId) {
        console.log('[MalwareAnalysis] Running Network Forensic Check');

        const commands = [
            'netstat -tulpn',
            'ss -ant',
            'arp -a'
        ];

        const results = [];
        for (const cmd of commands) {
            try {
                const output = await sandbox.executeCommand(sessionId, cmd);
                results.push({ command: cmd, output });
            } catch (e) { }
        }
        return results;
    }

    getReport(analysisId) {
        return this.analysisRuns.get(analysisId);
    }
}

module.exports = new MalwareAnalysisService();
